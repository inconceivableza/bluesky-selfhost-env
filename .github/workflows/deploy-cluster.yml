name: Deploy cluster

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - staging
          - production
      dry_run:
        description: 'Perform a dry-run deployment'
        required: false
        type: boolean
        default: false

jobs:
  deploy:
    name: Deploy to ${{ inputs.environment }} via SSH
    runs-on: ubuntu-22.04
    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ vars.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Test SSH connection
        run: |
          echo "Testing SSH connection..."
          ssh ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }} "echo '‚úì SSH connection successful'"

      - name: Fetch latest image tags from Docker Hub
        run: |
          echo "Fetching latest image tags from Docker Hub..."

          export BRANDED_NAMESPACE="${{ vars.BRANDED_NAMESPACE }}"

          SERVICES=(
            "foodios-atproto-bsky"
            "foodios-atproto-pds"
            "foodios-did-method-plc"
            "foodios-indigo-bgs"
            "foodios-indigo-palomar"
            "foodios-indigo-opensearch"
            "foodios-social-app"
            "foodios-social-card"
            "foodios-social-embed"
            "foodios-social-link"
            "ip-location-service-bsky"
            "otel-collector"
          )

          for REPO in "${SERVICES[@]}"; do
            echo "Fetching tags for ${BRANDED_NAMESPACE}/${REPO}..."

            RESPONSE=$(curl -s "https://registry.hub.docker.com/v2/repositories/${BRANDED_NAMESPACE}/${REPO}/tags/?page_size=1")
            LATEST_TAG=$(echo "$RESPONSE" | jq -r '.results[0].name')

            if [ -n "$LATEST_TAG" ] && [ "$LATEST_TAG" != "null" ]; then
              ENV_VAR_NAME=$(echo "${REPO}" | tr '[:lower:]' '[:upper:]' | tr '-' '_')_IMAGE_TAG
              echo "${ENV_VAR_NAME}=${LATEST_TAG}" >> $GITHUB_ENV
              echo "  ‚úì ${ENV_VAR_NAME}=${LATEST_TAG}"
            else
              echo "  ‚ö† No tags found for ${BRANDED_NAMESPACE}/${REPO}"
            fi

            sleep 0.5
          done

          echo ""
          echo "Image tag discovery complete"

      - name: Create values override file
        run: |
          cat > helm-values-override.yaml << 'EOF'
          # Auto-generated values for ${{ inputs.environment }} deployment
          # Generated at: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          # Global overrides
          global:
            namespace: "foodios-${{ inputs.environment }}"
            domain: "${{ vars.DOMAIN }}"
            imageRegistry: "${{ vars.BRANDED_NAMESPACE }}"
            tls:
              email: "${{ vars.EMAIL4CERTS }}"
              # Note: Cloudflare API token is stored as K8s secret, not in values

          # FQDNs (override from GitHub variables)
          fqdns:
            api: "${{ vars.APIFQDN }}"
            bgs: "${{ vars.BGSFQDN }}"
            bsky: "${{ vars.BSKYFQDN }}"
            card: "${{ vars.CARDFQDN }}"
            embed: "${{ vars.EMBEDFQDN }}"
            feedgen: "${{ vars.FEEDGENFQDN }}"
            ip: "${{ vars.IPFQDN }}"
            jaeger: jaeger.${{ vars.DOMAIN }}
            jetstream: "${{ vars.JETSTREAMFQDN }}"
            link: "${{ vars.LINKFQDN }}"
            ozone: "${{ vars.OZONEFQDN }}"
            palomar: "${{ vars.PALOMARFQDN }}"
            pds: "${{ vars.PDSFQDN }}"
            plc: "${{ vars.PLCFQDN }}"
            publicApi: "${{ vars.PUBLICAPIFQDN }}"
            socialapp: "${{ vars.SOCIALAPPFQDN }}"
            logs: "${{ vars.LOGSFQDN }}"

          # Image tags from Docker Hub
          pds:
            tag: "${{ env.FOODIOS_ATPROTO_PDS_IMAGE_TAG }}"

          bsky:
            tag: "${{ env.FOODIOS_ATPROTO_BSKY_IMAGE_TAG }}"

          plc:
            tag: "${{ env.FOODIOS_DID_METHOD_PLC_IMAGE_TAG }}"

          bgs:
            tag: "${{ env.FOODIOS_INDIGO_BGS_IMAGE_TAG }}"

          palomar:
            tag: "${{ env.FOODIOS_INDIGO_PALOMAR_IMAGE_TAG }}"

          socialApp:
            tag: "${{ env.FOODIOS_SOCIAL_APP_IMAGE_TAG }}"

          socialCard:
            tag: "${{ env.FOODIOS_SOCIAL_CARD_IMAGE_TAG }}"

          socialEmbed:
            tag: "${{ env.FOODIOS_SOCIAL_EMBED_IMAGE_TAG }}"

          socialLink:
            tag: "${{ env.FOODIOS_SOCIAL_LINK_IMAGE_TAG }}"

          opensearch:
            tag: "${{ env.FOODIOS_INDIGO_OPENSEARCH_IMAGE_TAG }}"

          ipcc:
            tag: "${{ env.IP_LOCATION_SERVICE_BSKY_IMAGE_TAG }}"

          otelCollector: 
            tag: ${{ env.OTEL_COLLECTOR_IMAGE_TAG }}

          jaeger:
            ingress:
              allowedIPs:
                - ${{ vars.VPN_IP_RANGE }}

          backup:
            restic:
              autoRemote: "${{ vars.RESTIC_AUTO_REMOTE }}"
              remoteRepo1: "${{ vars.RESTIC_REMOTE_REPO1 }}"
              remoteRepo2: "${{ vars.RESTIC_REMOTE_REPO2 }}"
              remoteRepo3: "${{ vars.RESTIC_REMOTE_REPO3 }}"
              awsAccessKeyId: "${{ vars.RESTIC_AWS_ACCESS_KEY_ID }}"
              googleProjectId: "${{ vars.RESTIC_GOOGLE_PROJECT_ID }}"

      - name: Create deployment directory on server
        run: |
          ssh ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }} "mkdir -p ~/helm-deploy/${{ inputs.environment }}"

      - name: Copy files to server
        run: |
          # Clean and copy Helm chart (removes old files)
          rsync -avz --delete foodios-chart/ \
            ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }}:~/helm-deploy/${{ inputs.environment }}/foodios-chart/

          # Copy values override
          scp helm-values-override.yaml \
            ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }}:~/helm-deploy/${{ inputs.environment }}/

      - name: Check and create Kubernetes secrets
        run: |
          ssh ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }} << 'ENDSSH'
            set -e  # Exit on any error

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üîê Checking Kubernetes secrets"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

            NAMESPACE="foodios-${{ inputs.environment }}"

            # Create namespace if it doesn't exist
            kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

            # Function to create or update secret
            create_or_update_secret() {
              local secret_name=$1
              shift
              local secret_data=("$@")

              echo "  üîê Creating/updating secret '$secret_name'..."
              kubectl create secret generic $secret_name -n $NAMESPACE "${secret_data[@]}" \
                --dry-run=client -o yaml | kubectl apply -f -
              echo "  ‚úÖ Applied secret '$secret_name'"
            }

            # Database secrets
            create_or_update_secret "db-secrets" \
              --from-literal=POSTGRES_PASSWORD='${{ secrets.POSTGRES_PASSWORD }}'

            # BGS secrets
            create_or_update_secret "bgs-secrets" \
              --from-literal=BGS_ADMIN_KEY='${{ secrets.BGS_ADMIN_KEY }}' \
              --from-literal=DATABASE_URL='${{ secrets.BGS_DATABASE_URL }}'

            # PDS secrets
            create_or_update_secret "pds-secrets" \
              --from-literal=PDS_JWT_SECRET='${{ secrets.PDS_JWT_SECRET }}' \
              --from-literal=PDS_ADMIN_PASSWORD='${{ secrets.PDS_ADMIN_PASSWORD }}' \
              --from-literal=PDS_PLC_ROTATION_KEY_K256_PRIVATE_KEY_HEX='${{ secrets.PDS_PLC_ROTATION_KEY_K256_PRIVATE_KEY_HEX }}'

            # Bsky secrets
            create_or_update_secret "bsky-secrets" \
              --from-literal=BSKY_DB_POSTGRES_URL='${{ secrets.BSKY_DB_POSTGRES_URL }}' \
              --from-literal=BSKY_SERVICE_SIGNING_KEY='${{ secrets.BSKY_SERVICE_SIGNING_KEY }}'

            # PLC secrets
            create_or_update_secret "plc-secrets" \
              --from-literal=DATABASE_URL='${{ secrets.PLC_DATABASE_URL }}' \
              --from-literal=DB_CREDS_JSON='${{ secrets.DB_CREDS_JSON }}' \
              --from-literal=DB_MIGRATE_CREDS_JSON='${{ secrets.DB_MIGRATE_CREDS_JSON }}'

            # Ozone secrets 
              create_or_update_secret "ozone-secrets" \
                --from-literal=DATABASE_URL='${{ secrets.OZONE_DB_POSTGRES_URL }}' \
                --from-literal=OZONE_ADMIN_PASSWORD='${{ secrets.OZONE_ADMIN_PASSWORD }}' \
                --from-literal=OZONE_SIGNING_KEY_HEX='${{ secrets.OZONE_SIGNING_KEY_HEX }}'
            
            # Palomar secrets
            create_or_update_secret "palomar-secrets" \
              --from-literal=DATABASE_URL='${{ secrets.PALOMAR_DATABASE_URL }}' \
              --from-literal=OPENSEARCH_INITIAL_ADMIN_PASSWORD='${{ secrets.OPENSEARCH_INITIAL_ADMIN_PASSWORD }}' \
              --from-literal=ES_PASSWORD='${{ secrets.OPENSEARCH_INITIAL_ADMIN_PASSWORD }}'

            # Social Link secrets
            create_or_update_secret "social-link-secrets" \
              --from-literal=DATABASE_URL='${{ secrets.LINK_DB_POSTGRES_URL }}' \
              --from-literal=LINK_DB_POSTGRES_URL='${{ secrets.LINK_DB_POSTGRES_MIGRATION_URL }}'

            # OpenSearch secrets
            create_or_update_secret "opensearch-secrets" \
              --from-literal=OPENSEARCH_INITIAL_ADMIN_PASSWORD='${{ secrets.OPENSEARCH_INITIAL_ADMIN_PASSWORD }}'

            # Backup secrets
            create_or_update_secret "backup-secrets" \
              --from-literal=POSTGRES_PASSWORD='${{ secrets.POSTGRES_PASSWORD }}' \
              --from-literal=PGPASSWORD='${{ secrets.POSTGRES_PASSWORD }}' \
              --from-literal=POSTGRES_USER='${{ secrets.POSTGRES_USER }}' \
              --from-literal=RESTIC_PASSWORD='${{ secrets.RESTIC_PASSWORD }}' \
              --from-literal=RESTIC_REMOTE_PASSWORD1='${{ secrets.RESTIC_REMOTE_PASSWORD1 }}' \
              --from-literal=RESTIC_REMOTE_PASSWORD2='${{ secrets.RESTIC_REMOTE_PASSWORD2 }}' \
              --from-literal=RESTIC_REMOTE_PASSWORD3='${{ secrets.RESTIC_REMOTE_PASSWORD3 }}' \
              --from-literal=RESTIC_AWS_SECRET_ACCESS_KEY='${{ secrets.RESTIC_AWS_SECRET_ACCESS_KEY }}' \
              --from-literal=AWS_SECRET_ACCESS_KEY='${{ secrets.RESTIC_AWS_SECRET_ACCESS_KEY }}'

            # Cloudflare credentials for Traefik ACME (in kube-system namespace)
            echo "  üîê Creating/updating secret 'cloudflare-credentials' in kube-system..."
            kubectl create secret generic cloudflare-credentials -n kube-system \
              --from-literal=CF_DNS_API_TOKEN='${{ secrets.CADDY_DNS_API_TOKEN }}' \
              --dry-run=client -o yaml | kubectl apply -f -
            echo "  ‚úÖ Applied secret 'cloudflare-credentials'"

            echo ""
            echo "‚úÖ All secrets verified/created"
            echo ""
            echo "Secrets in namespace:"
            kubectl get secrets -n $NAMESPACE
          ENDSSH

      - name: Lint Helm chart
        run: |
          ssh ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }} << 'ENDSSH'
            set -e  # Exit on any error
            cd ~/helm-deploy/${{ inputs.environment }}

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üîç Linting Helm chart"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

            helm lint ./foodios-chart \
              -f ./foodios-chart/values/${{ inputs.environment }}.yaml \
              -f ./helm-values-override.yaml

            echo "‚úì Lint successful"
          ENDSSH

      - name: Perform dry-run deployment
        if: inputs.dry_run == true
        run: |
          ssh ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }} << 'ENDSSH'
            set -e  # Exit on any error
            cd ~/helm-deploy/${{ inputs.environment }}

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üß™ Performing dry-run deployment"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

            helm upgrade --install foodios-${{ inputs.environment }} ./foodios-chart \
              --namespace foodios-${{ inputs.environment }} \
              --create-namespace \
              -f ./foodios-chart/values/${{ inputs.environment }}.yaml \
              -f ./helm-values-override.yaml \
              --dry-run \
              --debug | head -100

            echo ""
            echo "‚úÖ Dry-run completed successfully"
          ENDSSH

      - name: Deploy Helm chart
        if: inputs.dry_run == false
        run: |
          ssh ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }} << 'ENDSSH'
            set -e  # Exit on any error
            cd ~/helm-deploy/${{ inputs.environment }}

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üöÄ Deploying Helm chart to ${{ inputs.environment }}"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

            # Deploy with timeout and atomic rollback on failure
            if helm upgrade --install foodios-${{ inputs.environment }} ./foodios-chart \
              --namespace foodios-${{ inputs.environment }} \
              --create-namespace \
              -f ./foodios-chart/values/${{ inputs.environment }}.yaml \
              -f ./helm-values-override.yaml \
              --wait \
              --timeout 3m \
              --atomic; then

              echo ""
              echo "‚úÖ Helm deployment completed successfully"
            else
              echo ""
              echo "‚ùå Deployment failed or timed out"
              echo ""
              echo "üìã Pod Status:"
              kubectl get pods -n foodios-${{ inputs.environment }} -o wide

              echo ""
              echo "üîç Failed/Pending Pods:"
              kubectl get pods -n foodios-${{ inputs.environment }} \
                --field-selector=status.phase!=Running,status.phase!=Succeeded \
                -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,RESTARTS:.status.containerStatuses[0].restartCount 2>/dev/null || echo "No failed pods found"

              echo ""
              echo "üìÑ Recent Events:"
              kubectl get events -n foodios-${{ inputs.environment }} \
                --sort-by='.lastTimestamp' | tail -20

              echo ""
              echo "üí¨ Logs from Failed Pods:"
              for pod in $(kubectl get pods -n foodios-${{ inputs.environment }} \
                --field-selector=status.phase!=Running,status.phase!=Succeeded \
                -o jsonpath='{.items[*].metadata.name}' 2>/dev/null); do
                echo ""
                echo "=== Logs for $pod ==="
                kubectl logs -n foodios-${{ inputs.environment }} $pod \
                  --tail=50 --all-containers=true 2>&1 || echo "Could not fetch logs"
              done

              exit 1
            fi
          ENDSSH

      - name: Verify deployment
        if: inputs.dry_run == false
        run: |
          ssh ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }} << 'ENDSSH'
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìä Deployment Status"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

            kubectl get all -n foodios-${{ inputs.environment }}

            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã Helm Release Info"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

            helm list -n foodios-${{ inputs.environment }}
          ENDSSH

      - name: Wait for pods to be ready
        if: inputs.dry_run == false
        run: |
          ssh ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }} << 'ENDSSH'
            echo ""
            echo "‚è≥ Waiting for pods to be ready (max 5 min)..."

            kubectl wait --for=condition=ready pod \
              --all \
              -n foodios-${{ inputs.environment }} \
              --timeout=300s || true

            echo ""
            echo "üìà Final Pod Status:"
            kubectl get pods -n foodios-${{ inputs.environment }} \
              -o custom-columns='NAME:.metadata.name,STATUS:.status.phase,READY:.status.conditions[?(@.type=="Ready")].status,RESTARTS:.status.containerStatuses[0].restartCount'
          ENDSSH

      - name: Collect failure diagnostics
        if: failure() && inputs.dry_run == false
        run: |
          ssh ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }} << 'ENDSSH'
            echo ""
            echo "‚ùå Deployment had issues. Collecting diagnostics..."
            echo ""

            # Get failed pods
            FAILED_PODS=$(kubectl get pods -n foodios-${{ inputs.environment }} \
              --field-selector=status.phase!=Running \
              -o jsonpath='{.items[*].metadata.name}')

            if [ -n "$FAILED_PODS" ]; then
              for pod in $FAILED_PODS; do
                echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                echo "üìù Logs for pod: $pod"
                echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                kubectl logs $pod -n foodios-${{ inputs.environment }} --tail=50 2>&1 || echo "Could not get logs"

                echo ""
                echo "üîç Pod description:"
                kubectl describe pod $pod -n foodios-${{ inputs.environment }} | tail -30
                echo ""
              done
            else
              echo "No failed pods found, but deployment may have issues."
              echo "Recent events:"
              kubectl get events -n foodios-${{ inputs.environment }} --sort-by='.lastTimestamp' | tail -20
            fi
          ENDSSH

      - name: Cleanup local files
        if: always()
        run: |
          rm -f helm-values-override.yaml
          echo "üßπ Cleaned up local files"
