name: Deploy to Docker Swarm

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - staging
          - production
      force_recreate_secrets:
        description: 'Force recreate all Docker secrets (results in downtime)'
        required: false
        type: boolean
        default: false

jobs:
  deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ vars.SWARM_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment directory on server
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} "mkdir -p ~/deploy/${{ inputs.environment }}"

      - name: Create .env file from environment variables
        run: |
          cat > .env << 'EOF'
          # Generated from GitHub Environment: ${{ inputs.environment }}
          # Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          # Domain Configuration
          DOMAIN="${{ vars.DOMAIN }}"
          # FQDNs
          apiFQDN="${{ vars.APIFQDN }}"
          bgsFQDN="${{ vars.BGSFQDN }}"
          bskyFQDN="${{ vars.BSKYFQDN }}"
          cardFQDN="${{ vars.CARDFQDN }}"
          embedFQDN="${{ vars.EMBEDFQDN }}"
          feedgenFQDN="${{ vars.FEEDGENFQDN }}"
          ipFQDN="${{ vars.IPFQDN }}"
          jetstreamFQDN="${{ vars.JETSTREAMFQDN }}"
          linkFQDN="${{ vars.LINKFQDN }}"
          ozoneFQDN="${{ vars.OZONEFQDN }}"
          palomarFQDN="${{ vars.PALOMARFQDN }}"
          pdsFQDN="${{ vars.PDSFQDN }}"
          plcFQDN="${{ vars.PLCFQDN }}"
          publicApiFQDN="${{ vars.PUBLICAPIFQDN }}"
          socialappFQDN="${{ vars.SOCIALAPPFQDN }}"

          # Email Configuration
          EMAIL4CERTS="${{ vars.EMAIL4CERTS }}"
          PDS_EMAIL_FROM_ADDRESS="${{ vars.PDS_EMAIL_FROM_ADDRESS }}"
          PDS_EMAIL_IMAGES_BASE_URL="${{ vars.PDS_EMAIL_IMAGES_BASE_URL }}"
          PDS_EMAIL_SMTP_URL="${{ vars.PDS_EMAIL_SMTP_URL }}"

          # Image Configuration
          BRANDED_NAMESPACE="${{ vars.BRANDED_NAMESPACE }}"
          UNBRANDED_NAMESPACE="${{ vars.UNBRANDED_NAMESPACE }}"
          REBRANDING_NAME="${{ vars.REBRANDING_NAME }}"
          asof="${{ vars.ASOF }}"
          branded_asof="${{ vars.BRANDED_ASOF }}"

          # Database Configuration
          POSTGRES_USER="${{ vars.POSTGRES_USER }}"

          # Network Configuration
          docker_network="foodios-net"
          # TODO: remove
          CUSTOM_CERTS_DIR="/usr/local/share/ca-certificates"

          # TLS Configuration
          GOINSECURE="${{ vars.GOINSECURE }}"
          NODE_TLS_REJECT_UNAUTHORIZED="${{ vars.NODE_TLS_REJECT_UNAUTHORIZED }}"

          # Logging
          LOG_LEVEL_DEFAULT="${{ vars.LOG_LEVEL_DEFAULT || 'info' }}"

          # PDS Configuration
          PDS_INVITE_REQUIRED="${{ vars.PDS_INVITE_REQUIRED || 'false' }}"
          PDS_INVITE_INTERVAL="${{ vars.PDS_INVITE_INTERVAL }}"

          # Social App Configuration
          SOCIAL_APP_NAME="${{ vars.SOCIAL_APP_NAME }}"
          SOCIAL_APP_DESCRIPTION="${{ vars.SOCIAL_APP_DESCRIPTION }}"
          SOCIAL_APP_EMOJI="${{ vars.SOCIAL_APP_EMOJI }}"
          SOCIAL_APP_URL="${{ vars.SOCIAL_APP_URL }}"
          SOCIAL_HELP_DESK_URL="${{ vars.SOCIAL_HELP_DESK_URL }}"
          SOCIAL_POLICY_BASE_URL="${{ vars.SOCIAL_POLICY_BASE_URL }}"

          # Optional Configuration
          BSKY_LABELS_FROM_ISSUER_DIDS="${{ vars.BSKY_LABELS_FROM_ISSUER_DIDS }}"
          BSKY_STATSIG_ENV="${{ vars.BSKY_STATSIG_ENV }}"
          FEEDGEN_PUBLISHER_DID="${{ vars.FEEDGEN_PUBLISHER_DID }}"
          dmServiceDID="${{ vars.DMSERVICEDID }}"
          gifFQDN="${{ vars.GIFFQDN }}"
          OZONE_SERVER_DID="${{ vars.OZONE_SERVER_DID }}"
          OZONE_ADMIN_HANDLE="${{ vars.OZONE_ADMIN_HANDLE }}"
          OZONE_ADMIN_DIDS="${{ vars.OZONE_ADMIN_DIDS }}"

          # Statsig
          STATSIG_CLIENT_KEY="${{ vars.STATSIG_CLIENT_KEY }}"
          STATSIG_API_URL="${{ vars.STATSIG_API_URL }}"
          STATUS_PAGE_URL="${{ vars.STATUS_PAGE_URL }}"

          # Backup Configuration
          RESTIC_AUTO_REMOTE="${{ vars.RESTIC_AUTO_REMOTE }}"
          RESTIC_REMOTE_REPO1="${{ vars.RESTIC_REMOTE_REPO1 }}"
          RESTIC_REMOTE_REPO2="${{ vars.RESTIC_REMOTE_REPO2 }}"
          RESTIC_REMOTE_REPO3="${{ vars.RESTIC_REMOTE_REPO3 }}"
          RESTIC_AWS_ACCESS_KEY_ID="${{ secrets.RESTIC_AWS_ACCESS_KEY_ID }}"
          RESTIC_GOOGLE_PROJECT_ID="${{ vars.RESTIC_GOOGLE_PROJECT_ID }}"
          RESTIC_GOOGLE_APPLICATION_CREDENTIALS="${{ vars.RESTIC_GOOGLE_APPLICATION_CREDENTIALS }}"

          # Caddy Configuration
          CADDY_HTTP_PORT="${{ vars.CADDY_HTTP_PORT || '80' }}"
          CADDY_HTTPS_PORT="${{ vars.CADDY_HTTPS_PORT || '443' }}"
          CADDY_DNS_PROVIDER="${{ vars.CADDY_DNS_PROVIDER }}"
          CADDY_DNS_API_TOKEN="${{ secrets.CADDY_DNS_API_TOKEN }}"
          CADDY_DNS_RESOLVER="${{ vars.CADDY_DNS_RESOLVER }}"
          CADDY_DNS_USED="${{ vars.CADDY_DNS_USED }}"
          TRUSTED_PROXIES="${{ vars.TRUSTED_PROXIES }}"
          haproxyFORWARD="${{ vars.HAPROXY_FORWARD }}"

          # Update Certs Command
          UPDATE_CERTS_CMD="${{ vars.UPDATE_CERTS_CMD || 'true' }}"

          # Static Web Directory
          PDS_WEB_DIR="${{ vars.PDS_WEB_DIR || 'staticweb' }}"

          NODE_ENV="${{ inputs.environment }}"
          EOF

      - name: Create config directory structure
        run: |
          mkdir -p config/init-postgres config/backup config/caddy config/telemetry

      - name: Create database secrets file
        run: |
          cat > config/db-secrets.env << 'EOF'
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          EOF

      - name: Create BGS secrets file
        run: |
          cat > config/bgs-secrets.env << 'EOF'
          BGS_ADMIN_KEY=${{ secrets.BGS_ADMIN_KEY }}
          DATABASE_URL=${{ secrets.BGS_DATABASE_URL }}
          EOF

      - name: Create PDS secrets file
        run: |
          cat > config/pds-secrets.env << 'EOF'
          PDS_JWT_SECRET=${{ secrets.PDS_JWT_SECRET }}
          PDS_ADMIN_PASSWORD=${{ secrets.PDS_ADMIN_PASSWORD }}
          PDS_PLC_ROTATION_KEY_K256_PRIVATE_KEY_HEX=${{ secrets.PDS_PLC_ROTATION_KEY_K256_PRIVATE_KEY_HEX }}
          EOF

      - name: Create Bsky secrets file
        run: |
          cat > config/bsky-secrets.env << 'EOF'
          BSKY_DB_POSTGRES_URL=${{ secrets.BSKY_DB_POSTGRES_URL }}
          BSKY_SERVICE_SIGNING_KEY=${{ secrets.BSKY_SERVICE_SIGNING_KEY }}
          EOF

      - name: Create PLC secrets file
        run: |
          cat > config/plc-secrets.env << 'EOF'
          DATABASE_URL=${{ secrets.PLC_DATABASE_URL }}
          DB_CREDS_JSON=${{ secrets.DB_CREDS_JSON }}
          DB_MIGRATE_CREDS_JSON=${{ secrets.DB_MIGRATE_CREDS_JSON }}
          EOF

      - name: Create Ozone secrets file
        run: |
          cat > config/ozone-secrets.env << 'EOF'
          DATABASE_URL=${{ secrets.OZONE_DB_POSTGRES_URL }}
          OZONE_ADMIN_PASSWORD=${{ secrets.OZONE_ADMIN_PASSWORD }}
          OZONE_SIGNING_KEY_HEX=${{ secrets.OZONE_SIGNING_KEY_HEX }}
          EOF

      - name: Create OpenSearch secrets file
        run: |
          cat > config/opensearch-secrets.env << 'EOF'
          OPENSEARCH_INITIAL_ADMIN_PASSWORD=${{ secrets.OPENSEARCH_INITIAL_ADMIN_PASSWORD }}
          EOF

      - name: Create Palomar secrets file
        run: |
          cat > config/palomar-secrets.env << 'EOF'
          OPENSEARCH_INITIAL_ADMIN_PASSWORD=${{ secrets.OPENSEARCH_INITIAL_ADMIN_PASSWORD }}
          ES_PASSWORD=${{ secrets.OPENSEARCH_INITIAL_ADMIN_PASSWORD }}
          DATABASE_URL=${{ secrets.PALOMAR_DATABASE_URL }}
          EOF

      - name: Create Social Link secrets file
        run: |
          cat > config/social-link-secrets.env << 'EOF'
          DATABASE_URL=${{ secrets.LINK_DB_POSTGRES_URL }}
          LINK_DB_POSTGRES_URL=${{ secrets.LINK_DB_POSTGRES_MIGRATION_URL }}
          EOF

      - name: Create Backup secrets file
        run: |
          cat > config/backup-secrets.env << 'EOF'
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          RESTIC_REMOTE_PASSWORD1=${{ secrets.RESTIC_REMOTE_PASSWORD1 }}
          RESTIC_REMOTE_PASSWORD2=${{ secrets.RESTIC_REMOTE_PASSWORD2 }}
          RESTIC_REMOTE_PASSWORD3=${{ secrets.RESTIC_REMOTE_PASSWORD3 }}
          EOF

      - name: Create Caddy dynamic config
        run: |
          touch config/caddy-dynamic.env

      - name: Copy files to server
        run: |
          # Copy compose file
          scp docker-compose.swarm.yaml \
            ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }}:~/deploy/${{ inputs.environment }}/

          # Copy .env file
          scp .env \
            ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }}:~/deploy/${{ inputs.environment }}/

          # Copy config directory
          scp -r config/ \
            ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }}:~/deploy/${{ inputs.environment }}/

          # Copy other directories if they exist
          for dir in staticweb selfhost_scripts; do
            if [ -d "$dir" ]; then
              scp -r $dir/ \
                ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }}:~/deploy/${{ inputs.environment }}/
            fi
          done

      - name: Initialize Docker Swarm
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
              echo "Initializing Docker Swarm..."
              docker swarm init || docker swarm init --advertise-addr $(hostname -I | awk '{print $1}')
            else
              echo "Docker Swarm already active"
            fi
          ENDSSH

      - name: Manage Docker secrets
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            cd ~/deploy/${{ inputs.environment }}

            FORCE_RECREATE="${{ inputs.force_recreate_secrets }}"

            create_or_update_secret() {
              local secret_name="$1"
              local secret_file="$2"

              if [ ! -f "$secret_file" ]; then
                echo "‚ö†Ô∏è  Warning: $secret_file not found, skipping $secret_name"
                return
              fi

              if docker secret inspect "$secret_name" &> /dev/null; then
                if [ "$FORCE_RECREATE" = "true" ]; then
                  echo "üîÑ Recreating secret: $secret_name"
                  if ! docker secret rm "$secret_name" 2>/dev/null; then
                    echo "‚ùå Cannot remove $secret_name (in use by services)"
                    echo "   Run 'docker stack rm foodios-${{ inputs.environment }}' first to recreate secrets"
                    return 1
                  fi
                  docker secret create "$secret_name" "$secret_file"
                  echo "‚úÖ Recreated: $secret_name"
                else
                  echo "‚ÑπÔ∏è  Secret exists: $secret_name (skipping)"
                fi
              else
                echo "üîê Creating secret: $secret_name"
                docker secret create "$secret_name" "$secret_file"
                echo "‚úÖ Created: $secret_name"
              fi
            }

            echo "Managing Docker secrets..."
            STACK_NAME="foodios-${{ inputs.environment }}"
            if [ "$FORCE_RECREATE" = "true" ]; then
              echo "‚ö†Ô∏è Taking down services in order to recreate secrets"
              docker stack rm "$STACK_NAME"
            fi
            docker stack rm foodios-staging
            create_or_update_secret "db_secrets" "config/db-secrets.env"
            create_or_update_secret "bgs_secrets" "config/bgs-secrets.env"
            create_or_update_secret "pds_secrets" "config/pds-secrets.env"
            create_or_update_secret "bsky_secrets" "config/bsky-secrets.env"
            create_or_update_secret "plc_secrets" "config/plc-secrets.env"
            create_or_update_secret "ozone_secrets" "config/ozone-secrets.env"
            create_or_update_secret "opensearch_secrets" "config/opensearch-secrets.env"
            create_or_update_secret "palomar_secrets" "config/palomar-secrets.env"
            create_or_update_secret "social_link_secrets" "config/social-link-secrets.env"
            create_or_update_secret "backup_secrets" "config/backup-secrets.env"

            echo "‚úÖ Secrets management complete"
          ENDSSH

      - name: Deploy stack to Swarm
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            cd ~/deploy/${{ inputs.environment }}

            # Load environment variables
            set -a
            source .env
            set +a

            STACK_NAME="foodios-${{ inputs.environment }}"

            echo "üöÄ Deploying stack: $STACK_NAME"
            if docker stack deploy \
              -c docker-compose.swarm.yaml \
              "$STACK_NAME" \
              --with-registry-auth \
              --prune; then
              echo ""
              echo "‚úÖ Stack deployment command succeeded"
            else
              DEPLOY_EXIT_CODE=$?
              echo ""
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo "‚ùå ERROR: Stack deployment failed with exit code $DEPLOY_EXIT_CODE"
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo ""
              echo "Checking docker-compose.swarm.yaml syntax..."
              docker compose -f docker-compose.swarm.yaml config > /dev/null 2>&1 || echo "‚ö†Ô∏è  Compose file may have syntax errors"
              echo ""
              echo "Current stack services (if any):"
              docker stack services "$STACK_NAME" 2>&1 || echo "No services found"
              exit 1
            fi

            sleep 5

            echo ""
            echo "üìä Initial Service Status:"
            docker stack services "$STACK_NAME"
          ENDSSH

      - name: Wait for services
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            STACK_NAME="foodios-${{ inputs.environment }}"
            echo "‚è≥ Waiting for services to start..."

            TIMEOUT=60
            ELAPSED=0
            INTERVAL=10

            while [ $ELAPSED -lt $TIMEOUT ]; do
              SERVICES_TOTAL=$(docker stack services "$STACK_NAME" --format "{{.Name}}" | wc -l)
              SERVICES_READY=$(docker stack ps "$STACK_NAME" \
                --filter "desired-state=running" \
                --format "{{.CurrentState}}" | grep -c "Running" || true)

              echo "üìà Services ready: $SERVICES_READY/$SERVICES_TOTAL (${ELAPSED}s/${TIMEOUT}s)"

              if [ "$SERVICES_READY" -ge "$((SERVICES_TOTAL * 8 / 10))" ]; then
                echo "‚úÖ Deployment successful! Most services are running."
                docker stack services "$STACK_NAME"
                exit 0
              fi

              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            done

            echo "‚ö†Ô∏è  Timeout reached. Current status:"
            docker stack services "$STACK_NAME"
            docker stack ps "$STACK_NAME" --no-trunc | head -20
            exit 1
          ENDSSH

      - name: Show deployment status
        if: always()
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            STACK_NAME="foodios-${{ inputs.environment }}"

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìä Final Deployment Status"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker stack services "$STACK_NAME"

            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã Service Tasks"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker stack ps "$STACK_NAME" \
              --filter "desired-state=running" \
              --format "table {{.Name}}\t{{.CurrentState}}\t{{.Error}}" \
              | head -30
          ENDSSH

      - name: Cleanup sensitive files
        if: always()
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            cd ~/deploy/${{ inputs.environment }}
            rm -f config/*-secrets.env
            echo "üßπ Cleaned up sensitive files"
          ENDSSH

      - name: Collect failure diagnostics
        if: failure()
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            STACK_NAME="foodios-${{ inputs.environment }}"
            echo "‚ùå Deployment failed. Collecting diagnostics..."

            for service in $(docker stack services "$STACK_NAME" -q | head -10); do
              service_name=$(docker service inspect $service --format '{{.Spec.Name}}')
              echo ""
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo "üìù Logs: $service_name"
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              docker service logs --tail 50 $service 2>&1 || true
            done
          ENDSSH
