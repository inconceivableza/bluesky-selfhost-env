name: Deploy to Docker Swarm

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - staging
          - production
      force_recreate_secrets:
        description: 'Force recreate all Docker secrets'
        required: false
        type: boolean
        default: false

jobs:
  deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ vars.SWARM_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment directory on server
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} "mkdir -p ~/bluesky-deploy/${{ inputs.environment }}"

      - name: Create .env file from environment variables
        run: |
          cat > .env << 'EOF'
          # Generated from GitHub Environment: ${{ inputs.environment }}
          # Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          # Domain Configuration
          DOMAIN=${{ vars.DOMAIN }}
          HOST_HOSTNAME=${{ vars.HOST_HOSTNAME }}

          # FQDNs
          apiFQDN=${{ vars.API_FQDN }}
          bgsFQDN=${{ vars.BGS_FQDN }}
          bskyFQDN=${{ vars.BSKY_FQDN }}
          cardFQDN=${{ vars.CARD_FQDN }}
          embedFQDN=${{ vars.EMBED_FQDN }}
          feedgenFQDN=${{ vars.FEEDGEN_FQDN }}
          ipFQDN=${{ vars.IP_FQDN }}
          jetstreamFQDN=${{ vars.JETSTREAM_FQDN }}
          linkFQDN=${{ vars.LINK_FQDN }}
          ozoneFQDN=${{ vars.OZONE_FQDN }}
          palomarFQDN=${{ vars.PALOMAR_FQDN }}
          pdsFQDN=${{ vars.PDS_FQDN }}
          plcFQDN=${{ vars.PLC_FQDN }}
          publicApiFQDN=${{ vars.PUBLIC_API_FQDN }}
          socialappFQDN=${{ vars.SOCIAL_APP_FQDN }}

          # Email Configuration
          EMAIL4CERTS=${{ vars.EMAIL_FOR_CERTS }}
          PDS_EMAIL_FROM_ADDRESS=${{ vars.PDS_EMAIL_FROM_ADDRESS }}
          PDS_EMAIL_IMAGES_BASE_URL=${{ vars.PDS_EMAIL_IMAGES_BASE_URL }}
          PDS_EMAIL_SMTP_URL=${{ secrets.PDS_EMAIL_SMTP_URL }}

          # Image Configuration
          BRANDED_NAMESPACE=${{ vars.BRANDED_NAMESPACE }}
          UNBRANDED_NAMESPACE=${{ vars.UNBRANDED_NAMESPACE }}
          REBRANDING_NAME=${{ vars.REBRANDING_NAME }}
          asof=${{ vars.IMAGE_TAG_ASOF }}
          branded_asof=${{ vars.IMAGE_TAG_BRANDED_ASOF }}

          # Database Configuration
          POSTGRES_USER=${{ vars.POSTGRES_USER }}

          # Network Configuration
          docker_network=foodios-net
          CUSTOM_CERTS_DIR=/usr/local/share/ca-certificates

          # TLS Configuration
          GOINSECURE=${{ vars.GOINSECURE }}
          NODE_TLS_REJECT_UNAUTHORIZED=${{ vars.NODE_TLS_REJECT_UNAUTHORIZED }}

          # Logging
          LOG_LEVEL_DEFAULT=${{ vars.LOG_LEVEL_DEFAULT || 'info' }}

          # PDS Configuration
          PDS_INVITE_REQUIRED=${{ vars.PDS_INVITE_REQUIRED || 'false' }}
          PDS_INVITE_INTERVAL=${{ vars.PDS_INVITE_INTERVAL }}

          # Social App Configuration
          SOCIAL_APP_NAME=${{ vars.SOCIAL_APP_NAME }}
          SOCIAL_APP_DESCRIPTION=${{ vars.SOCIAL_APP_DESCRIPTION }}
          SOCIAL_APP_EMOJI=${{ vars.SOCIAL_APP_EMOJI }}
          SOCIAL_APP_URL=${{ vars.SOCIAL_APP_URL }}
          SOCIAL_HELP_DESK_URL=${{ vars.SOCIAL_HELP_DESK_URL }}
          SOCIAL_POLICY_BASE_URL=${{ vars.SOCIAL_POLICY_BASE_URL }}

          # Optional Configuration
          BSKY_LABELS_FROM_ISSUER_DIDS=${{ vars.BSKY_LABELS_FROM_ISSUER_DIDS }}
          BSKY_STATSIG_ENV=${{ vars.BSKY_STATSIG_ENV }}
          FEEDGEN_PUBLISHER_DID=${{ vars.FEEDGEN_PUBLISHER_DID }}
          dmServiceDID=${{ vars.DM_SERVICE_DID }}
          gifFQDN=${{ vars.GIF_FQDN }}
          OZONE_SERVER_DID=${{ vars.OZONE_SERVER_DID }}
          OZONE_ADMIN_HANDLE=${{ vars.OZONE_ADMIN_HANDLE }}
          OZONE_ADMIN_DIDS=${{ vars.OZONE_ADMIN_DIDS }}

          # Statsig
          STATSIG_CLIENT_KEY=${{ vars.STATSIG_CLIENT_KEY }}
          STATSIG_API_URL=${{ vars.STATSIG_API_URL }}
          STATUS_PAGE_URL=${{ vars.STATUS_PAGE_URL }}

          # Backup Configuration
          RESTIC_AUTO_REMOTE=${{ vars.RESTIC_AUTO_REMOTE }}
          RESTIC_REMOTE_REPO1=${{ vars.RESTIC_REMOTE_REPO1 }}
          RESTIC_REMOTE_REPO2=${{ vars.RESTIC_REMOTE_REPO2 }}
          RESTIC_REMOTE_REPO3=${{ vars.RESTIC_REMOTE_REPO3 }}
          RESTIC_AWS_ACCESS_KEY_ID=${{ secrets.RESTIC_AWS_ACCESS_KEY_ID }}
          RESTIC_GOOGLE_PROJECT_ID=${{ vars.RESTIC_GOOGLE_PROJECT_ID }}
          RESTIC_GOOGLE_APPLICATION_CREDENTIALS=${{ vars.RESTIC_GOOGLE_APPLICATION_CREDENTIALS }}

          # Caddy Configuration
          CADDY_HTTP_PORT=${{ vars.CADDY_HTTP_PORT || '80' }}
          CADDY_HTTPS_PORT=${{ vars.CADDY_HTTPS_PORT || '443' }}
          CADDY_DNS_PROVIDER=${{ vars.CADDY_DNS_PROVIDER }}
          CADDY_DNS_API_TOKEN=${{ secrets.CADDY_DNS_API_TOKEN }}
          CADDY_DNS_RESOLVER=${{ vars.CADDY_DNS_RESOLVER }}
          CADDY_DNS_USED=${{ vars.CADDY_DNS_USED }}
          TRUSTED_PROXIES=${{ vars.TRUSTED_PROXIES }}
          haproxyFORWARD=${{ vars.HAPROXY_FORWARD }}

          # Update Certs Command
          UPDATE_CERTS_CMD=${{ vars.UPDATE_CERTS_CMD || 'true' }}

          # Static Web Directory
          PDS_WEB_DIR=${{ vars.PDS_WEB_DIR || 'staticweb' }}
          EOF

      - name: Create config directory structure
        run: |
          mkdir -p config/init-postgres config/backup config/caddy config/telemetry

      - name: Create database secrets file
        run: |
          cat > config/db-secrets.env << 'EOF'
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          EOF

      - name: Create BGS secrets file
        run: |
          cat > config/bgs-secrets.env << 'EOF'
          BGS_ADMIN_KEY=${{ secrets.BGS_ADMIN_KEY }}
          DATABASE_URL=${{ secrets.BGS_DATABASE_URL }}
          EOF

      - name: Create PDS secrets file
        run: |
          cat > config/pds-secrets.env << 'EOF'
          PDS_JWT_SECRET=${{ secrets.PDS_JWT_SECRET }}
          PDS_ADMIN_PASSWORD=${{ secrets.PDS_ADMIN_PASSWORD }}
          PDS_PLC_ROTATION_KEY_K256_PRIVATE_KEY_HEX=${{ secrets.PDS_PLC_ROTATION_KEY }}
          DATABASE_URL=${{ secrets.PDS_DATABASE_URL }}
          EOF

      - name: Create Bsky secrets file
        run: |
          cat > config/bsky-secrets.env << 'EOF'
          DATABASE_URL=${{ secrets.BSKY_DATABASE_URL }}
          BSKY_APPVIEW_DB_POSTGRES_URL=${{ secrets.BSKY_APPVIEW_DB_URL }}
          EOF

      - name: Create PLC secrets file
        run: |
          cat > config/plc-secrets.env << 'EOF'
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          DATABASE_URL=${{ secrets.PLC_DATABASE_URL }}
          DB_CREDS_JSON=${{ secrets.PLC_DB_CREDS_JSON }}
          DB_MIGRATE_CREDS_JSON=${{ secrets.PLC_DB_MIGRATE_CREDS_JSON }}
          EOF

      - name: Create Ozone secrets file
        run: |
          cat > config/ozone-secrets.env << 'EOF'
          DATABASE_URL=${{ secrets.OZONE_DATABASE_URL }}
          OZONE_ADMIN_PASSWORD=${{ secrets.OZONE_ADMIN_PASSWORD }}
          OZONE_SIGNING_KEY_HEX=${{ secrets.OZONE_SIGNING_KEY_HEX }}
          EOF

      - name: Create OpenSearch secrets file
        run: |
          cat > config/opensearch-secrets.env << 'EOF'
          ES_PASSWORD=${{ secrets.OPENSEARCH_PASSWORD }}
          OPENSEARCH_INITIAL_ADMIN_PASSWORD=${{ secrets.OPENSEARCH_ADMIN_PASSWORD }}
          EOF

      - name: Create Palomar secrets file
        run: |
          cat > config/palomar-secrets.env << 'EOF'
          ES_PASSWORD=${{ secrets.OPENSEARCH_PASSWORD }}
          EOF

      - name: Create Social Link secrets file
        run: |
          cat > config/social-link-secrets.env << 'EOF'
          DATABASE_URL=${{ secrets.SOCIAL_LINK_DATABASE_URL }}
          LINK_DB_POSTGRES_URL=${{ secrets.SOCIAL_LINK_DATABASE_URL }}
          EOF

      - name: Create Backup secrets file
        run: |
          cat > config/backup-secrets.env << 'EOF'
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          RESTIC_REMOTE_PASSWORD1=${{ secrets.RESTIC_REMOTE_PASSWORD1 }}
          RESTIC_REMOTE_PASSWORD2=${{ secrets.RESTIC_REMOTE_PASSWORD2 }}
          RESTIC_REMOTE_PASSWORD3=${{ secrets.RESTIC_REMOTE_PASSWORD3 }}
          EOF

      - name: Create Caddy dynamic config
        run: |
          touch config/caddy-dynamic.env

      - name: Copy files to server
        run: |
          # Copy compose file
          scp docker-compose.swarm.yaml \
            ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }}:~/deploy/${{ inputs.environment }}/

          # Copy .env file
          scp .env \
            ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }}:~/deploy/${{ inputs.environment }}/

          # Copy config directory
          scp -r config/ \
            ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }}:~/deploy/${{ inputs.environment }}/

          # Copy other directories if they exist
          for dir in staticweb selfhost_scripts; do
            if [ -d "$dir" ]; then
              scp -r $dir/ \
                ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }}:~/deploy/${{ inputs.environment }}/
            fi
          done

      - name: Initialize Docker Swarm
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
              echo "Initializing Docker Swarm..."
              docker swarm init || docker swarm init --advertise-addr $(hostname -I | awk '{print $1}')
            else
              echo "Docker Swarm already active"
            fi
          ENDSSH

      - name: Manage Docker secrets
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            cd ~/deploy/${{ inputs.environment }}

            FORCE_RECREATE="${{ inputs.force_recreate_secrets }}"

            create_or_update_secret() {
              local secret_name="$1"
              local secret_file="$2"

              if [ ! -f "$secret_file" ]; then
                echo "‚ö†Ô∏è  Warning: $secret_file not found, skipping $secret_name"
                return
              fi

              if docker secret inspect "$secret_name" &> /dev/null; then
                if [ "$FORCE_RECREATE" = "true" ]; then
                  echo "üîÑ Recreating secret: $secret_name"
                  if ! docker secret rm "$secret_name" 2>/dev/null; then
                    echo "‚ùå Cannot remove $secret_name (in use by services)"
                    echo "   Run 'docker stack rm foodios-${{ inputs.environment }}' first to recreate secrets"
                    return 1
                  fi
                  docker secret create "$secret_name" "$secret_file"
                  echo "‚úÖ Recreated: $secret_name"
                else
                  echo "‚ÑπÔ∏è  Secret exists: $secret_name (skipping)"
                fi
              else
                echo "üîê Creating secret: $secret_name"
                docker secret create "$secret_name" "$secret_file"
                echo "‚úÖ Created: $secret_name"
              fi
            }

            echo "Managing Docker secrets..."
            create_or_update_secret "db_secrets" "config/db-secrets.env"
            create_or_update_secret "bgs_secrets" "config/bgs-secrets.env"
            create_or_update_secret "pds_secrets" "config/pds-secrets.env"
            create_or_update_secret "bsky_secrets" "config/bsky-secrets.env"
            create_or_update_secret "plc_secrets" "config/plc-secrets.env"
            create_or_update_secret "ozone_secrets" "config/ozone-secrets.env"
            create_or_update_secret "opensearch_secrets" "config/opensearch-secrets.env"
            create_or_update_secret "palomar_secrets" "config/palomar-secrets.env"
            create_or_update_secret "social_link_secrets" "config/social-link-secrets.env"
            create_or_update_secret "backup_secrets" "config/backup-secrets.env"

            echo "‚úÖ Secrets management complete"
          ENDSSH

      - name: Deploy stack to Swarm
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            cd ~/deploy/${{ inputs.environment }}

            # Load environment variables
            set -a
            source .env
            set +a

            STACK_NAME="foodios-${{ inputs.environment }}"

            echo "üöÄ Deploying stack: $STACK_NAME"
            docker stack deploy \
              -c docker-compose.swarm.yaml \
              "$STACK_NAME" \
              --with-registry-auth \
              --prune

            echo "‚úÖ Deployment command executed"
            sleep 5

            echo ""
            echo "üìä Service Status:"
            docker stack services "$STACK_NAME"
          ENDSSH

      - name: Wait for services
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            STACK_NAME="foodios-${{ inputs.environment }}"
            echo "‚è≥ Waiting for services to start..."

            TIMEOUT=600
            ELAPSED=0
            INTERVAL=10

            while [ $ELAPSED -lt $TIMEOUT ]; do
              SERVICES_TOTAL=$(docker stack services "$STACK_NAME" --format "{{.Name}}" | wc -l)
              SERVICES_READY=$(docker stack ps "$STACK_NAME" \
                --filter "desired-state=running" \
                --format "{{.CurrentState}}" | grep -c "Running" || true)

              echo "üìà Services ready: $SERVICES_READY/$SERVICES_TOTAL (${ELAPSED}s/${TIMEOUT}s)"

              if [ "$SERVICES_READY" -ge "$((SERVICES_TOTAL * 8 / 10))" ]; then
                echo "‚úÖ Deployment successful! Most services are running."
                docker stack services "$STACK_NAME"
                exit 0
              fi

              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            done

            echo "‚ö†Ô∏è  Timeout reached. Current status:"
            docker stack services "$STACK_NAME"
            docker stack ps "$STACK_NAME" --no-trunc | head -20
            exit 1
          ENDSSH

      - name: Show deployment status
        if: always()
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            STACK_NAME="foodios-${{ inputs.environment }}"

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìä Final Deployment Status"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker stack services "$STACK_NAME"

            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìã Service Tasks"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            docker stack ps "$STACK_NAME" \
              --filter "desired-state=running" \
              --format "table {{.Name}}\t{{.CurrentState}}\t{{.Error}}" \
              | head -30
          ENDSSH

      - name: Cleanup sensitive files
        if: always()
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            cd ~/bluesky-deploy/${{ inputs.environment }}
            rm -f config/*-secrets.env
            echo "üßπ Cleaned up sensitive files"
          ENDSSH

      - name: Collect failure diagnostics
        if: failure()
        run: |
          ssh ${{ vars.SWARM_USER }}@${{ vars.SWARM_HOST }} << 'ENDSSH'
            STACK_NAME="foodios-${{ inputs.environment }}"
            echo "‚ùå Deployment failed. Collecting diagnostics..."

            for service in $(docker stack services "$STACK_NAME" -q | head -10); do
              service_name=$(docker service inspect $service --format '{{.Spec.Name}}')
              echo ""
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo "üìù Logs: $service_name"
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              docker service logs --tail 50 $service 2>&1 || true
            done
          ENDSSH
