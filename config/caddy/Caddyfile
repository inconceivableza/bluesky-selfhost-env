#
# this mapping rules are converted into Caddyfile from traefik rules of https://github.com/ikuradon/atproto-starter-kit/blob/main/compose.yaml
# cf. https://caddyserver.com/docs/caddyfile
#
# global options: starts >>>>

(haproxy_support_true) {
	# for getting real IP if forwarded over these networks
	trusted_proxies static 127.0.0.1/32 {$TRUSTED_PROXIES}
	# for supporting haproxy forwarding requests over PROXY protocol to allow ip detection - see .env
	listener_wrappers {
		proxy_protocol {
			timeout 2s
			allow 127.0.0.1/32
			allow {$TRUSTED_PROXIES}
		}
		tls
	}
}

(haproxy_support_false) {
}

(haproxy_support_) {
}

{
	#	debug
	on_demand_tls {
		permission http "http://caddy-sidecar:80" # this just response with 200 to everything so will allow all certificates
	}
	servers {
		#    limits to HTTP/1.1 >>>
		protocols h1
		# optional haproxy forwarding support - should be set to `true` or left empty
		import haproxy_support_{$haproxyFORWARD}
	}
	#    limits to HTTP/1.1 <<<
	metrics {
		per_host
	}
}

# https://caddy.community/t/how-can-i-allow-multiple-domain-origins-in-cors/22129/5
(cors) {
	@cors_preflight {
		method OPTIONS
	}
	@corsOrigin {
		header_regexp Origin ^https?://.*({$DOMAIN})$
	}

	handle @cors_preflight {
		header {
			Access-Control-Allow-Origin "*"
			Access-Control-Allow-Methods "GET, POST, PUT, PATCH, DELETE"
			Access-Control-Allow-Headers "Authorization,*"
			Vary Origin
			defer
		}
		respond "" 204
	}

	handle @corsOrigin {
		header {
			Access-Control-Allow-Origin "*"
			Access-Control-Expose-Headers *
			Vary Origin
			defer
		}
	}
}

# opentelemetry tracing. takes desired span name as parameter
(tracing) {
	tracing {
		span caddy-{args[0]}
	}
}

(tracing_reverse_proxy) {
	handle {args[0]} {
		tracing {
			span caddy-{args[2]}
		}
		reverse_proxy {args[1]}
	}
}

# global options: ends   <<<<

# separate port for metrics from the admin port
:2020 {
	metrics
}

# self-hosting CA with ACME,  for self signed certicates >>>>
#   accessible as https://ca.DOMAIN:9000/acme/local/directory
#   cf. https://blog.kurokobo.com/archives/3669#Caddy_acme_server
#
ca.{$DOMAIN}:9000 {
	tls internal
	acme_server
}
# self-hosting CA with ACME,  for self signed certicates <<<<

# starts; reverse proxying rules >>>>>
#
#  FQDN_FOR_OUTER {
#	tls internal(for self-signed) | your@email.address(for public-signed) {
#         on_demand
#       }
#       reverse_proxy http://container:port
# }

# starts: to check if sidecar working, this record maybe need just for debugging. >>>>
#caddy-sidecar.{$DOMAIN} {
#       import cors
#	tls {$EMAIL4CERTS} {
#	  on_demand
#       }
#	reverse_proxy http://caddy-sidecar:80
#}
# ends: to check if sidecar working, this record maybe need just for debugging. <<<<

# starts: to check if caddy works as reverse proxy, for HTTP(S) and WS(S) >>>>>>>>>>
#  for HTTPS/WSS => HTTP/WS, you can test websocket by ```wscat -c wss://test-wss.mybluesky.local.com/ws```
test-wss.{$DOMAIN} {
	import cors
	tls {$EMAIL4CERTS} {
		on_demand
	}

	@ws {
		header Connection *Upgrade*
		header Upgrade websocket
	}

	reverse_proxy @ws http://test-wss:8080
	reverse_proxy http://test-wss:8080
}

#  for HTTP/WS => HTTP/WS, you can test websocket by ```wscat -c ws://test-ws.mybluesky.local.com/ws```
http://test-ws.{$DOMAIN} {
	import cors
	tls {$EMAIL4CERTS} {
		on_demand
	}
	@ws {
		header Connection *Upgrade*
		header Upgrade websocket
	}

	reverse_proxy @ws http://test-ws:8080
	reverse_proxy http://test-ws:8080
}

# ends: to check if caddy works as reverse proxy, for HTTP(S) and WS(S) <<<<<<<<<<

# starts: simple mapping >>>>>

{$plcFQDN} {
	import cors
	import tracing plc
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy http://plc:2582
}

{$bgsFQDN} {
	import cors
	import tracing bgs-relay
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy {$bgsPROXY:http://bgs:2470}
}

{$apiFQDN}, {$publicApiFQDN}, {$bskyFQDN} {
	import cors
	import tracing bsky
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy {$bskyPROXY:http://bsky:2584}
}

{$socialappFQDN} {
	import cors
	import tracing social-app
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy {$socialappPROXY:http://social-app:8100}
}

yarnstart.{$DOMAIN} {
	import cors
	import tracing social-app
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy {$socialappyarnPROXY:http://host.docker.internal:8081}
}

{$cardFQDN} {
	import cors
	import tracing social-card
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy http://social-card:3003
}

{$embedFQDN} {
	import cors
	import tracing social-embed
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy http://social-embed:8101
}

{$linkFQDN} {
	import cors
	import tracing social-link
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy {$sociallinkPROXY:http://social-link:3004}
}

{$ipFQDN} {
	import cors
	import tracing ipcc
	tls {$EMAIL4CERTS} {
		on_demand
	}
	@config {
		path /config
	}
	log {
		format json
	}
	reverse_proxy @config http://ipcc:8080 {
		header_up X-Real-IP {remote_host}
	}
}

{$ozoneFQDN} {
	import cors
	import tracing ozone
	tls {$EMAIL4CERTS} {
		on_demand
	}
	#	reverse_proxy http://ozone:3006
	reverse_proxy http://ozone-standalone:3005
}
ozone-standalone.{$DOMAIN} {
	import cors
	import tracing ozone-standalone
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy http://ozone-standalone:3005
}

{$palomarFQDN} {
	import cors
	import tracing palomar
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy http://palomar:3999
}

{$feedgenFQDN} {
	import cors
	import tracing {$feedgenFQDN}
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy http://feed-generator:3008
}

{$jetstreamFQDN} {
	import cors
	import tracing jetstream
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy http://jetstream:6008
}

{$logsFQDN} {
	import cors
	import tracing logs-dashboard
	tls {$EMAIL4CERTS} {
		on_demand
	}
	reverse_proxy http://opensearch-dashboards:5601
}

{$pdsFQDN} {
	# import cors # disabled as pds serves its own CORS headers which then conflict
	tls {$EMAIL4CERTS} {
		on_demand
	}

	@ws {
		header Connection *Upgrade*
		header Upgrade websocket
	}

	@xrpc {
		path /xrpc/*
	}
	import tracing_reverse_proxy @ws {$pdsPROXY:http://pds:2583} pds-websocket
	import tracing_reverse_proxy @xrpc {$pdsPROXY:http://pds:2583} pds-xrpc
	# serve the social app's website on this domain, as well as xrpc
	root * /socialweb/
	handle {
		file_server
		import tracing pds-social-web
	}
}
# ends:  simple mapping <<<<<

# these import definitions are used to conditionally do caddy dns setup based on CADDY_DNS_USED
(dns_plugin_true) {
	dns {$CADDY_DNS_PROVIDER} {$CADDY_DNS_API_TOKEN}
	resolvers {$CADDY_DNS_RESOLVER}
}

(dns_plugin_false) {
}

(dns_plugin_) {
}

# starts:  *.pdsFQDN (pds.DOMAIN) >>>>>>>>>>>
*.{$pdsFQDN} {
	import cors
	tls {$EMAIL4CERTS} {
		#         enables wildcards
		import dns_plugin_{$CADDY_DNS_USED} # this should be set to `true` or `false` (leaving empty is like `false`)
	}
	#  it needs both of header_regexp and path_regexp with rewrite then reverse_proxy.
	#---------------
	#      websocket
	@ws {
		header Connection *Upgrade*
		header Upgrade websocket
		header_regexp host Host ^(.*)\.{$pdsFQDN}$
		path_regexp path ^(.*)
	}
	rewrite @ws {http.regexp.path.1}
	import tracing_reverse_proxy @ws {$pdsPROXY:http://pds:2583} pds-profile-websocket

	#---------------
	#      *.pdsFQDN/xrpc*  => http://pds:2583
	@xrpc {
		header_regexp host Host ^(.*)\.{$pdsFQDN}$
		path_regexp path ^(/xrpc.*)
	}
	rewrite @xrpc {http.regexp.path.1}
	import tracing_reverse_proxy @xrpc {$pdsPROXY:http://pds:2583} pds-profile-xrpc

	#---------------
	#      *.pdsFQDN/.well-known* => http://pds:2583
	@wellknown {
		header_regexp host Host ^(.*)\.{$pdsFQDN}$
		path_regexp path ^(/\.well-known.*)
	}
	rewrite @wellknown {http.regexp.path.1}
	import tracing_reverse_proxy @wellknown {$pdsPROXY:http://pds:2583} pds-profile-well-known

	#---------------
	#      *.pdsFQDN/robots.txt* => http://pds:2583
	@robots {
		header_regexp host Host ^(.*)\.{$pdsFQDN}$
		path_regexp path ^(/robots\.txt*)
	}
	rewrite @robots {http.regexp.path.1}
	import tracing_reverse_proxy @robots {$pdsPROXY:http://pds:2583} pds-profile-robots

	#---------------
	#     (.*).pdsFQDN/(.*) => http://social-app:8100/profile/$$1/$$2
	@others {
		header_regexp host Host ^(.*)\.{$pdsFQDN}$
		# this must exclude all above paths, as redir has a higher priority than rewrite
		not {
			path /xrpc* /.well-known* /robots.txt*
		}
		path_regexp path ^(.*)
	}
	redir @others https://{$socialappFQDN}/profile/{host}{http.regexp.path.1}
	import tracing_reverse_proxy @others http://social-app:8100 pds-profile-others
}
# ends: *.pdsFQDN <<<<<<<<<<<
